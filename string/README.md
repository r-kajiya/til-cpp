# 文字列はコピーたくさん発生するので取り扱いには十分注意する

    // Aを生成

    std::string a = "A"

    // Bを生成

    std::string b = "B"

    // a+bの一時変数xを生成後, cにxをコピー

    std::string c = a + b;

    //a+bの一時変数xを生成後, x+cの一時変数yを生成, その後yをdにコピー

    std::string d = a + b + c;

# 一時変数をなくす

    std::string a;

    // a + "!"の一時変数生成後aにコピー

    a = a + "!";

    // 連結代入演算子を使用するため一時変数を作成しないので先ほどより軽い

    a += "!";

# 先に割り当てることで無駄な領域を確保しない

    std::string a;

    // 文字列20個分メモリ確保

    a.reserve(20);

    // 18文字代入、20個分確保しているので、メモリ再割り当てとコピーは発生しない

    a = "123456789123456789";

    // 21文字代入、無駄に大きい再割り当て(自分の環境では31個分確保)と18文字分のコピーが発生

    a = "123456789123456789123";

しかし、20と指定したからと言ってcapacityが20になるわけではなく、自分の環境だと指定していない状態で15,31と法則で増えていった。

あるcapacity数からメモリ確保の差が出てきたので指定したほうが良い、速度に大差はなかった

# constを意識する

引き数として渡し、変更しない文字列ならconstをつけることで無駄なコピー変更のコストを防げるかも？

処理系によるところが大きいらしいのでよくわからない

# stringではなくchar[]を使用する

そもそもcharを使用する。利便性は完全に失われるが、速度やメモリの面では圧倒的に有利

# 参考URL

<http://d.hatena.ne.jp/s-yata/20110109/1294627973>
